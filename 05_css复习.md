### css选择器的读取顺序
    从右往左

### 样式表的组成
      规则
        选择器+声明块
                声明
        *{
          margin:0,
          color:deeppink
        }
        div{
          color:pink
        }

### css声明的优先级
    选择器的特殊性
        选择器的特殊性由选择器本身的组件确定，特殊性值表述为4个部分，如 0,0,0,0
        一个选择器的具体特殊性如下确定：
               1.对于选择器中给定的ID属性值，加 0,1,0,0
               2.对于选择器中给定的各个类属性，属性选择，或伪类，加 0,0,1,0
               3.对于选择器中的给定的各个元素和伪元素，加0,0,0,1
               4.通配符选择器的特殊性为0,0,0,0
               5.结合符对选择器特殊性没有一点贡献
               6.内联声明的特殊性都是1,0,0,0
               7.继承没有特殊性

            特殊性 1,0,0,0 大于所有以0开头的特殊性(不进位)
            选择器的特殊性最终都会授予给其对应的声明
            如果多个规则与同一个元素匹配，而且有些声明互相冲突时，特殊性越大的越占优势

            注意：id选择器和属性选择器
                  div[id="test"]（0,0,1,1） 和 #test（0,1,0,0）
    继承
        继承没有特殊性，甚至连0特殊性都没有
        0特殊性要比无特殊性来的强

    重要声明
        有时某个声明比较重要，超过了所有其他声明，css2.1就称之为重要声明
        并允许在这些声明的结束分号之前插入  !important  来标志
        必须要准确的放置  !important 否则声明无效。
        !important 总是要放在声明的最后，即分号的前面

         标志为 !important的声明并没有特殊的特殊性值，不过要与非重要声明分开考虑。
         实际上所有的重要声明会被浏览器分为一组，重要声明的冲突会在其内部解决
         非重要声明也会被分为一组，非重要声明的冲突也会在其内部解决
         如果一个重要声明与非重要声明冲突，胜出的总是重要声明

    来源
        css样式的来源大致有三种
          用户代理
          创作人员
          读者

        权重：
           读者的重要声明 (ie)
           创作人员的重要声明
           创作人员的正常声明
           读者的正常声明 (ie)
           用户代理的正常声明

    层叠(一个元素命中了多个相同的声明)
        1.找出所有相关的规则，这些规则都包含一个选择器
        2.计算声明的优先级
               先按来源排序
               在按选择器的特殊性排序
               最终按顺序

### 元素垂直水平居中的方案
    已知高宽
    未知高宽

### flex
#### 两组核心概念
    1. 容器 项目
    2. 主轴 侧轴

#### 一条基本原则
    项目永远排列找主侧轴的正方向上

#### 容器上的属性
    a. 控制主侧轴是哪一根 及其方向
        flex-direction      控制主轴方向 row x轴  column y      reverse 反方向
        flex-wrap           控制是否换行    
        flex-flow           控制富裕空间 
    b. 控制主侧轴的富裕空间的位置
        justify-content     富裕空间的管理（主轴）
        align-items         富裕空间的管理（侧轴）
        align-content        属性定义弹性容器的侧轴方向上有额外空间时，如何排布每一行/列。当弹性容器只有一行/列时无作用

#### 项目上的属性
    align-self : 控制项目本身富余空间的位置
    order      : 控制项目本身的排列属性 值越大越往后
    flex       : 实现项目的等分等比例布局
                flex-grow flex-shrink flex-basis简写属性
                flex:2 等价于 flex-grow:2  flex-shrink:1 flex-basis:0%

#### 事件冒泡
    所谓的事件冒泡其实就是事件的向上传导,当后代的元素的事件被触发时,其祖先的相同事件元也会被触发. 我们可以将其绑定给元素的共同的祖先元素 通过冒泡来对其就行控制

#### 事件流
    DOM事件流存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡
    捕获和冒泡  如何传播? 
        捕获: 由外向内
        冒泡: 由内向外

#### js性能优化篇

    a:  作用域的注意 脚本中随着作用域的增加  访问当前作用域以外变量的时间也会变慢 由于遍历作用域是会需要时间的,所以应在作用域上面做文章.
    b:  2  尽可能地少用with 语句，因为它会增加with 语句以外的数据的访问代价；
        3  不可滥用闭包，否则会影响到执行速度以及内存；
        4  嵌套的对象成员会明显影响性能，尽量少用；
        5  避免多次访问对象成员或函数中的全局变量，尽量将它们赋值给局部变量以缓存。
    
    
        1  最小化dom访问次数，尽可能在js端执行；
        2  如果需要多次访问某个dom节点，请使用局部变量存储对它的引用；
        3  小心处理html集合，因为它实时连系着底层的文档，把集合的长度缓存到一个变量中，并在迭代中使用它，如果需要经常操作集合，建议把它拷贝到一个数组中；
        4  如果可能的话，使用速度更快的API，比如querySelectorAll和firstElementChild；
        5  要留意重绘和重排；批量修改样式时，“离线”操作dom树；使用缓存，并减少访问布局的次数；
        6  动画中使用绝对定位，使用拖放代理
        7  使用事件委托来减少事件处理器的数量
        8  关于JS的循环，循环是一种常用的流程控制。JS提供了三种循环：for(;?、while()、for(in)。在这三种循环中 for(in)的效率最差，因为它需要查询Hash键，因此应尽量少用for(in)循环，for(;?、while()循环的性能基本持平。当然，推 荐使用for循环，如果循环变量递增或递减，不要单独对循环变量赋值，而应该使用嵌套的++或－－运算符。
        9  如果需要遍历数组，应该先缓存数组长度，将数组长度放入局部变量中，避免多次查询数组长度。
        10  局部变量的访问速度要比全局变量的访问速度更快，因为全局变量其实是window对象的成员，而局部变量是放在函数的栈里的。
        11  尽量少使用eval，每次使用eval需要消耗大量时间，这时候使用JS所支持的闭包可以实现函数模板。
        12  尽量避免对象的嵌套查询，对于obj1.obj2.obj3.obj4这个语句，需要进行至少3次查询操作，先检查obj1中是否包含 obj2，再检查obj2中是否包含obj3，然后检查obj3中是否包含obj4…这不是一个好策略。应该尽量利用局部变量，将obj4以局部变量 保存，从而避免嵌套查询。
        13  使运算符时，尽量使用+＝，－＝、*＝、=等运算符号，而不是直接进行赋值运算。
        14  当需要将数字转换成字符时，采用如下方式："" + 1。从性能上来看，将数字转换成字符时，有如下公式：("" +) > String() > .toString() > new String()。String()属于内部函数，所以速度很快。而.toString()要查询原型中的函数，所以速度逊色一些，new String()需要重新创建一个字符串对象，速度最慢。
        15  当需要将浮点数转换成整型时，应该使用Math.floor()或者Math.round()。而不是使用parseInt(),该方法 用于将字符串转换成数字。而且Math是内部对象，所以Math.floor()其实并没有多少查询方法和调用时间，速度是最快的。
        16  尽量用JSON格式来创建对象，而不是var obj=new Object()方法。因为前者是直接复制，而后者需要调用构造器，因而前者的性能更好。
        17  当需要使用数组时，也尽量使用JSON格式的语法，即直接使用如下语法定义数组：[parrm,param,param…],而不是采用 new Array(parrm,param,param…)这种语法。因为使用JSON格式的语法是引擎直接解释的。而后者则需要调用Array的构造器。
        18  对字符串进行循环操作，例如替换、查找，就使用正则表达式。因为JS的循环速度比较慢，而正则表达式的操作是用C写成的API，性能比较好。
        19  对于大的JS对象，因为创建时时间和空间的开销都比较大，因此应该尽量考虑采用缓存。

####